# Анализ системных вызовов с помощью strace

## Описание задания

Анализ работы программы с использованием утилиты `strace` для отслеживания системных вызовов. Программа читает данные из стандартного ввода (stdin) и записывает их в стандартный вывод (stdout).

### Задачи:
1. Написать программу на C, которая читает из stdin и пишет в stdout
2. Использовать системные вызовы `read()` и `write()`
3. Проанализировать программу с помощью `strace`
4. Подсчитать количество вызовов `read()` и `write()` для работы с stdin/stdout
5. Сохранить результаты анализа

## Требования

- **Язык программирования**: C
- **Системные вызовы**: `read()`, `write()`
- **Инструмент анализа**: `strace`
- **Автоматизация**: bash-скрипт для анализа
- **Результаты**: сохранение в понятном формате

## Файлы проекта

- `task.c` - исходный код программы на C
- `analyze.sh` - скрипт для автоматического анализа
- `README.md` - документация (этот файл)

## Программа task.c

```c
#include <unistd.h>

int main() {
    char buf[10];      // Буфер размером 10 байт
    int n;             // Количество прочитанных байт
    
    // Читаем из stdin (файловый дескриптор 0) и пишем в stdout (файловый дескриптор 1)
    while ((n = read(0, buf, sizeof(buf))) > 0) {
        write(1, buf, n);
    }
    
    return 0;
}

Особенности программы:
Использует только системные вызовы (без стандартной библиотеки ввода/вывода)

Читает данные блоками по 10 байт

Записывает прочитанные данные сразу

Цикл завершается при получении EOF (read возвращает 0)

Скрипт анализа analyze.sh

#!/bin/bash
# Компилируем программу
gcc -o task task.c 2>/dev/null

# Запускаем strace с тестовыми данными
# Ищем только вызовы read(0, ...) и write(1, ...) - работа с stdin/stdout
echo "${1:-test}" | strace ./task 2>&1 | awk '
    /read\(0,/ {r++}      # Считаем вызовы read из stdin (fd=0)
    /write\(1,/ {w++}     # Считаем вызовы write в stdout (fd=1)
    END {
        print "read:", r
        print "write:", w
    }'

# Удаляем скомпилированную программу
rm -f task 2>/dev/null
Особенности скрипта:
Принимает тестовые данные как аргумент (по умолчанию "test")

Компилирует программу автоматически

Использует strace для отслеживания системных вызовов

Фильтрует только вызовы для stdin (0) и stdout (1)

Автоматически очищает временные файлы

Инструкция по использованию
1. Установка прав доступа:

chmod +x analyze.sh
2. Базовый запуск (с тестовой строкой "test"):

./analyze.sh
3. Запуск с разными тестовыми данными:

# Короткая строка
./analyze.sh "hello"

# Длинная строка (более 10 символов)
./analyze.sh "hello world"

# Специальные случаи
./analyze.sh " "          # Пробел
./analyze.sh ""           # Пустая строка
./analyze.sh "1234567890" # Ровно 10 символов
4. Ручной анализ (без скрипта):

# Компиляция программы
gcc -o task task.c

# Просмотр всех системных вызовов
echo "test data" | strace ./task

# Только вызовы read/write для stdin/stdout
echo "test data" | strace ./task 2>&1 | grep -E "(read\(0,|write\(1,)"

# Подсчет вручную
echo "test data" | strace ./task 2>&1 | grep -c "read\(0,"
echo "test data" | strace ./task 2>&1 | grep -c "write\(1,"
Примеры вывода
Тест 1: Короткая строка "hello"

./analyze.sh "hello"
Вывод:

text
read: 2
write: 1
Объяснение:

read: 2 - чтение "hello\n" (6 байт) + EOF

write: 1 - запись "hello\n" за один вызов

Тест 2: Длинная строка "hello world" (11 символов + \n = 12 байт)

./analyze.sh "hello world"
Вывод:

text
read: 3
write: 2
Объяснение:

Буфер 10 байт, поэтому:

1-й read: "hello worl" (10 байт) → write

2-й read: "d\n" (2 байта) → write

3-й read: EOF (0 байт)

Тест 3: Пустая строка

./analyze.sh ""
Вывод:

text
read: 1
write: 0
Объяснение:

read: 1 - сразу получаем EOF

write: 0 - ничего не записываем

Принцип работы
Алгоритм программы:
Выделить буфер размером 10 байт

В цикле:

Читать до 10 байт из stdin в буфер

Если прочитано > 0 байт, записать их в stdout

Если прочитано 0 байт (EOF), завершить цикл

Алгоритм анализа:
Скомпилировать программу

Запустить strace с тестовыми данными

Найти все вызовы read(0, ...) (чтение из stdin)

Найти все вызовы write(1, ...) (запись в stdout)

Подсчитать количество найденных вызовов

Объяснение вывода strace
Пример полного вывода для echo "hello" | strace ./task:

text
read(0, "hello\n", 10)                 = 6
write(1, "hello\n", 6)                 = 6
read(0, "", 10)                        = 0
Расшифровка:

read(0, "hello\n", 10) - чтение 6 байт из stdin (fd=0)

write(1, "hello\n", 6) - запись 6 байт в stdout (fd=1)

read(0, "", 10) - попытка чтения, получен EOF (0 байт)

Формула расчета количества вызовов
Для строки длиной N байт (включая \n):

Вызовов read() = ceil(N / 10) + 1 (последний для EOF)

Вызовов write() = ceil(N / 10)

Примеры:

"hello" (6 байт): read=2, write=1

"hello world" (12 байт): read=3, write=2

"1234567890" (11 байт): read=2, write=1

Возможные проблемы и решения
Проблема: "strace: command not found"

# Ubuntu/Debian
sudo apt-get install strace

# CentOS/RHEL
sudo yum install strace
Проблема: "Permission denied"

chmod +x analyze.sh
chmod +x task  # после компиляции
Проблема: Неверный подсчет
Убедитесь, что скрипт ищет именно read(0, и write(1,, а не все вызовы read/write.

Расширенные возможности
Анализ с разным размером буфера:
Измените sizeof(buf) в программе и проанализируйте разницу.

Сравнение с буферизированным вводом/выводом:
Напишите программу с fread()/fwrite() и сравните количество системных вызовов.

Анализ производительности:

# С таймированием
strace -T ./task < large_file.txt

# Статистика
strace -c ./task < test_data.txt
Заключение
Это задание демонстрирует:

Работу с низкоуровневыми системными вызовами ввода/вывода

Использование strace для анализа поведения программ

Понимание взаимодействия программы с ядром ОС

Автоматизацию анализа с помощью bash-скриптов

Программа является минимальным примером, но показывает фундаментальные принципы работы с файловыми дескрипторами и системными вызовами в Unix-подобных системах.

## Дополнительно: если нужен файл `analysis.txt`

Добавьте в `analyze.sh`:
```bash
#!/bin/bash
# Компилируем
gcc -o task task.c 2>/dev/null

# Запускаем и сохраняем в файл
echo "${1:-test}" | strace ./task 2>&1 | awk '
    /read\(0,/ {r++; print "read: "$0} 
    /write\(1,/ {w++; print "write: "$0} 
    END {
        print "=== ИТОГО ==="
        print "read: " r
        print "write: " w
    }' > analysis.txt

# Показываем результат
cat analysis.txt

# Удаляем временные файлы
rm -f task 2>/dev/null